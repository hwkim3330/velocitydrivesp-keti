export function looksLikeGzip(u8){ return u8 && u8.length>2 && u8[0]===0x1f && u8[1]===0x8b; }
export function buildProxiedUrl(url, proxyBase){ if(!proxyBase) return url; const b=String(proxyBase).trim(); if(/corsproxy\.io\/?\?$/.test(b)) return `${b}${encodeURIComponent(url)}`; if(/\/(fetch|proxy)$/.test(b)) return `${b}?url=${encodeURIComponent(url)}`; return `${b.replace(/\/$/,'')}/fetch?url=${encodeURIComponent(url)}`; }
export async function extractSidFromArchive(bytes,name){ let tar=bytes; const low=(name||'').toLowerCase(); if(low.endsWith('.tgz')||low.endsWith('.tar.gz')||looksLikeGzip(bytes)){ if(typeof DecompressionStream==='undefined') throw new Error('No gzip support'); const ds=new DecompressionStream('gzip'); const gun=new Uint8Array(await new Response(new Response(bytes).body.pipeThrough(ds)).arrayBuffer()); tar=gun; } const files=parseTar(tar), mapping={}, stats={}; for(const f of files){ if(f.name.endsWith('.sid')){ try{ const j=JSON.parse(new TextDecoder().decode(f.data)); const mn=j['module-name']||'unknown'; let c=0; (j.items||[]).forEach(it=>{ if(it.namespace==='data'&&it.sid&&it.identifier){ mapping[it.sid]=it.identifier; c++; } }); stats[mn]=c; }catch{} } } return {mapping,moduleStats:stats}; }
export function parseTar(u8){ const out=[],B=512; let i=0; while(i+B<=u8.length){ const h=u8.subarray(i,i+B); if(h.every(b=>b===0)) break; const name=new TextDecoder().decode(h.subarray(0,100)).replace(/\0.*$/,''); const size=parseInt(new TextDecoder().decode(h.subarray(124,136)).replace(/\0.*$/,'').trim(),8)||0; const st=i+B,en=st+size; out.push({name,data:u8.subarray(st,en)}); i=en+((B-(size%B||B))%B); } return out; }

