<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>🚀 VelocityDRIVE-SP Web Control Center</title>
<style>
/* Light Theme (Apple-like) */
:root {
  --bg-primary: #ffffff;
  --bg-secondary: #f5f7fb;
  --bg-card: #ffffff;
  --bg-hover: #f0f3f9;
  --border: #e5e7eb;
  --text-primary: #111827;
  --text-secondary: #4b5563;
  --text-muted: #6b7280;
  --accent: #3b82f6; /* Blue point color */
  --accent-hover: #2563eb;
  --success: #10b981;
  --warning: #f59e0b;
  --error: #ef4444;
  --code-bg: #f8fafc;
  --shadow: 0 8px 24px rgba(17, 24, 39, 0.06);
  /* Touch-friendly sizing defaults */
  --base-font-size: 14px;
  --control-height: 36px;
  --control-radius: 12px;
  --tap-padding-y: 10px;
  --tap-padding-x: 14px;
}
/* Touch mode variable overrides */
.touch-mode {
  --base-font-size: 17px;
  --control-height: 48px;
  --control-radius: 16px;
  --tap-padding-y: 14px;
  --tap-padding-x: 18px;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
  background: var(--bg-primary);
  color: var(--text-primary);
  height: 100vh;
  overflow: hidden;
  font-size: var(--base-font-size);
  -webkit-tap-highlight-color: transparent;
}

/* Header */
.header {
  background: var(--bg-primary);
  border-bottom: 1px solid var(--border);
  padding: 0.75rem 1.5rem;
  display: flex;
  align-items: center;
  gap: 1rem;
  height: 60px;
  position: sticky;
  top: 0;
  z-index: 10;
}

.logo {
  font-size: 1.25rem;
  font-weight: 600;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  margin-right: auto;
}

.btn {
  background: var(--bg-card);
  color: var(--text-primary);
  border: 1px solid var(--border);
  padding: var(--tap-padding-y) var(--tap-padding-x);
  min-height: var(--control-height);
  border-radius: var(--control-radius);
  cursor: pointer;
  font-size: 0.875rem;
  transition: all 0.2s;
  box-shadow: var(--shadow);
}

.btn:hover {
  background: var(--bg-hover);
  border-color: var(--accent);
}

.btn-primary {
  background: var(--accent);
  border-color: var(--accent);
}

.btn-primary:hover {
  background: var(--accent-hover);
}

.btn-danger {
  background: var(--error);
  border-color: var(--error);
}

.status {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem 1rem;
  background: var(--bg-card);
  border-radius: 0.5rem;
  font-size: 0.875rem;
}

.status-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--text-muted);
}

.status-dot.connected {
  background: var(--success);
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

/* Main Layout */
.container {
  display: flex;
  height: calc(100vh - 60px);
}

/* Sidebar */
.sidebar {
  width: 320px;
  background: var(--bg-secondary);
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
}

.sidebar-header {
  padding: 1rem;
  border-bottom: 1px solid var(--border);
  font-weight: 600;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.search-box {
  padding: 0.5rem 1rem;
  border-bottom: 1px solid var(--border);
}

.search-input {
  width: 100%;
  padding: var(--tap-padding-y) var(--tap-padding-x);
  background: var(--bg-primary);
  border: 1px solid var(--border);
  border-radius: var(--control-radius);
  color: var(--text-primary);
  font-size: 0.875rem;
}

.search-input:focus {
  outline: none;
  border-color: var(--accent);
}

.tree-view {
  flex: 1;
  overflow-y: auto;
  padding: 0.5rem;
}

/* Enhanced Tree Styles */
.tree-module {
  margin-bottom: 0.5rem;
}

.tree-module-header {
  padding: 0.5rem;
  background: var(--bg-card);
  border-radius: 0.25rem;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.875rem;
  transition: background 0.2s;
}

.tree-module-header:hover {
  background: var(--bg-hover);
}

.tree-module-content {
  padding-left: 1rem;
  margin-top: 0.25rem;
}

.tree-item {
  padding: calc(var(--tap-padding-y) * 0.8) var(--tap-padding-x);
  cursor: pointer;
  border-radius: 0.25rem;
  margin-bottom: 0.125rem;
  font-size: 0.95rem;
  display: flex;
  align-items: center;
  gap: 0.375rem;
  color: var(--text-secondary);
  transition: all 0.2s;
}

.tree-item:hover {
  background: var(--bg-hover);
  color: var(--text-primary);
}

.tree-item.selected {
  background: var(--accent);
  color: white;
}

.tree-icon {
  font-size: 0.875rem;
  opacity: 0.8;
}

.tree-label {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.tree-sid {
  font-size: 0.625rem;
  background: var(--bg-primary);
  padding: 0.125rem 0.25rem;
  border-radius: 0.125rem;
  opacity: 0.7;
}

.tree-expand {
  font-size: 0.75rem;
  margin-left: auto;
}

/* Main Content */
.main {
  flex: 1;
  display: flex;
  flex-direction: column;
}

.tabs {
  display: flex;
  gap: 0.5rem;
  padding: 1rem;
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border);
}

.tab {
  padding: var(--tap-padding-y) var(--tap-padding-x);
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 0.5rem 0.5rem 0 0;
  cursor: pointer;
  font-size: 0.95rem;
  transition: all 0.2s;
  min-height: var(--control-height);
  display: flex;
  align-items: center;
}

.tab.active {
  background: var(--accent);
  border-color: var(--accent);
  color: white;
}

.content {
  flex: 1;
  padding: 1rem;
  overflow-y: auto;
}

.panel {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 1rem;
  margin-bottom: 1rem;
  box-shadow: var(--shadow);
}

.panel-header {
  padding: 1rem;
  border-bottom: 1px solid var(--border);
  font-weight: 600;
  background: var(--bg-hover);
  border-radius: 0.5rem 0.5rem 0 0;
}

.panel-content {
  padding: 1rem;
}

.log {
  background: var(--code-bg);
  border: 1px solid var(--border);
  border-radius: var(--control-radius);
  height: 300px;
  overflow-y: auto;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
  font-size: 0.9rem;
  padding: var(--tap-padding-y) var(--tap-padding-x);
}

.log-entry {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.25rem 0;
  border-bottom: 1px solid rgba(45, 55, 72, 0.3);
}

.log-time {
  color: var(--text-muted);
  min-width: 80px;
}

.log-direction {
  min-width: 40px;
  padding: 0.125rem 0.25rem;
  border-radius: 0.25rem;
  font-size: 0.625rem;
  font-weight: 600;
}

.log-direction.send { background: var(--accent); }
.log-direction.recv { background: var(--success); }
.log-direction.info { background: var(--warning); }

.log-type {
  min-width: 60px;
  color: var(--accent);
  font-weight: 600;
}

.log-data {
  color: var(--text-secondary);
  font-family: monospace;
  word-break: break-all;
  flex: 1;
}

.form-group {
  margin-bottom: 1rem;
}

.form-label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: 600;
  color: var(--text-secondary);
}

.form-input {
  width: 100%;
  padding: var(--tap-padding-y) var(--tap-padding-x);
  background: var(--bg-primary);
  border: 1px solid var(--border);
  border-radius: var(--control-radius);
  color: var(--text-primary);
  font-family: inherit;
  min-height: var(--control-height);
}

.form-input:focus {
  outline: none;
  border-color: var(--accent);
}

textarea.form-input {
  min-height: 120px;
  resize: vertical;
  font-family: monospace;
}

select.form-input {
  cursor: pointer;
}

.alert {
  padding: 1rem;
  border-radius: 0.5rem;
  margin-bottom: 1rem;
}

.alert-error {
  background: rgba(239, 68, 68, 0.1);
  border: 1px solid rgba(239, 68, 68, 0.3);
  color: #fca5a5;
}

.alert-success {
  background: rgba(16, 185, 129, 0.1);
  border: 1px solid rgba(16, 185, 129, 0.3);
  color: #6ee7b7;
}

.alert-warning {
  background: rgba(245, 158, 11, 0.1);
  border: 1px solid rgba(245, 158, 11, 0.3);
  color: #fcd34d;
}

.stats-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 1rem;
  margin-bottom: 1rem;
}

.stat-card {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 0.5rem;
  padding: 1rem;
  text-align: center;
}

.stat-value {
  font-size: 1.5rem;
  font-weight: bold;
  color: var(--accent);
}

.stat-label {
  color: var(--text-secondary);
  font-size: 0.875rem;
  margin-top: 0.25rem;
}

/* Scrollbar Styles */
.sidebar::-webkit-scrollbar,
.tree-view::-webkit-scrollbar,
.log::-webkit-scrollbar,
.content::-webkit-scrollbar {
  width: 6px;
}

.sidebar::-webkit-scrollbar-track,
.tree-view::-webkit-scrollbar-track,
.log::-webkit-scrollbar-track,
.content::-webkit-scrollbar-track {
  background: var(--bg-primary);
}

.sidebar::-webkit-scrollbar-thumb,
.tree-view::-webkit-scrollbar-thumb,
.log::-webkit-scrollbar-thumb,
.content::-webkit-scrollbar-thumb {
  background: var(--border);
  border-radius: 3px;
}

.sidebar::-webkit-scrollbar-thumb:hover,
.tree-view::-webkit-scrollbar-thumb:hover,
.log::-webkit-scrollbar-thumb:hover,
.content::-webkit-scrollbar-thumb:hover {
  background: var(--text-muted);
}
</style>
</head>
<body>
  <div class="header">
    <div class="logo">🚀 VelocityDRIVE-SP Web Control Center</div>
    <div class="status" id="connectionStatus">
      <div class="status-dot" id="statusDot"></div>
      <span id="statusText">Disconnected</span>
    </div>
    <button class="btn btn-primary" id="connectBtn" onclick="connectDevice()">Connect</button>
    <button class="btn btn-danger" id="disconnectBtn" onclick="disconnectDevice()" style="display:none;">Disconnect</button>
    <input type="file" id="sidFile" accept=".json,.js,.sid,.yaml,.yml" style="display:none" onchange="onImportSidFile(event)">
    <input type="file" id="coreconfDir" webkitdirectory directory multiple style="display:none" onchange="onImportCoreconfFolder(event)">
    <button class="btn" onclick="document.getElementById('sidFile').click()">Import SID</button>
    <button class="btn" onclick="document.getElementById('coreconfDir').click()">Import Coreconf Folder</button>
    <button class="btn" onclick="exportSidMap()">Export SID</button>
    <button class="btn" onclick="resetSidMap()">Reset SID</button>
    <button class="btn" onclick="toggleTouchMode()">Touch Mode</button>
  </div>

  <div class="container">
    <div class="sidebar">
      <div class="sidebar-header">
        <span>📋 YANG Module Browser</span>
      </div>
      <div class="search-box">
        <input type="text" class="search-input" id="yangSearch" placeholder="Search YANG paths..." onkeyup="searchYangPaths(this.value)">
      </div>
      <div class="tree-view" id="yangTree">
        <!-- Tree will be populated by JavaScript -->
      </div>
    </div>

    <div class="main">
      <div class="tabs">
        <div class="tab active" data-tab="monitor">📊 Monitor</div>
        <div class="tab" data-tab="config">⚙️ Configuration</div>
        <div class="tab" data-tab="raw">🛠️ Raw CoAP</div>
        <div class="tab" data-tab="tsn">🧩 TSN</div>
        <div class="tab" data-tab="test">🧪 Test</div>
        <div class="tab" data-tab="stats">📈 Statistics</div>
      </div>

      <div class="content">
        <!-- Monitor Tab -->
        <div id="monitorTab">
          <div class="panel">
            <div class="panel-header">📡 Communication Log</div>
            <div class="panel-content">
              <div style="margin-bottom: 1rem;">
                <button class="btn" onclick="clearLog()">Clear Log</button>
                <button class="btn" onclick="exportLog()">Export Log</button>
              </div>
              <div class="log" id="logOutput"></div>
            </div>
          </div>
        </div>

        <!-- Configuration Tab -->
        <div id="configTab" style="display:none">
          <div class="panel">
            <div class="panel-header">⚙️ Configuration Manager</div>
            <div class="panel-content">
              <div class="form-group">
                <label class="form-label">Selected YANG Path</label>
                <input type="text" class="form-input" id="configPath" readonly>
                <small style="color: var(--text-muted);">Select a path from the tree browser</small>
              </div>
              <div class="form-group">
                <button class="btn btn-primary" onclick="getConfig()">📥 Get Configuration</button>
                <button class="btn btn-primary" onclick="setConfig()">📤 Set Configuration</button>
                <button class="btn" onclick="formatJson()">🎨 Format JSON</button>
              </div>
              <div class="form-group">
                <label class="form-label">Configuration Data (JSON)</label>
                <textarea class="form-input" id="configData" placeholder='{"enabled": true, "name": "eth0"}'></textarea>
              </div>
            </div>
          </div>
        </div>

        <!-- Test Tab -->
        <div id="testTab" style="display:none">
          <div class="panel">
            <div class="panel-header">🧪 Communication Test Suite</div>
            <div class="panel-content">
              <div class="form-group">
                <h4 style="margin-bottom: 0.5rem; color: var(--text-secondary);">Basic Tests</h4>
                <button class="btn btn-primary" onclick="testPing()">📡 Test Ping</button>
                <button class="btn btn-primary" onclick="testCoapMode()">🔄 Test CoAP Mode</button>
              </div>
              <div class="form-group">
                <h4 style="margin-bottom: 0.5rem; color: var(--text-secondary);">YANG Module Tests</h4>
                <button class="btn btn-primary" onclick="testGetInterfaces()">🔌 Test Interfaces</button>
                <button class="btn btn-primary" onclick="testGetSystem()">⚙️ Test System</button>
                <button class="btn btn-primary" onclick="testGetBridge()">🌉 Test Bridge</button>
              </div>
              <div class="form-group">
                <label class="form-label">Test Results</label>
                <textarea class="form-input" id="testResults" readonly style="height: 200px;"></textarea>
              </div>
            </div>
          </div>
        </div>

        <!-- Raw CoAP Tab -->
        <div id="rawTab" style="display:none">
          <div class="panel">
            <div class="panel-header">🛠️ Raw CoAP Message Builder</div>
            <div class="panel-content">
              <div class="form-group">
                <label class="form-label">Method</label>
                <select class="form-input" id="coapMethod">
                  <option value="GET">GET - Retrieve data</option>
                  <option value="POST">POST - Create resource</option>
                  <option value="PUT">PUT - Update resource</option>
                  <option value="DELETE">DELETE - Remove resource</option>
                </select>
              </div>
              <div class="form-group">
                <label class="form-label">URI Path</label>
                <input type="text" class="form-input" id="coapUri" placeholder="/ietf-interfaces:interfaces">
                <small style="color: var(--text-muted);">YANG path to query (select from tree or type manually)</small>
              </div>
              <div class="form-group">
                <label class="form-label">Payload (CBOR Hex)</label>
                <textarea class="form-input" id="coapPayload" placeholder="A1 19 07F1 F5"></textarea>
                <small style="color: var(--text-muted);">CBOR-encoded payload in hex format (optional)</small>
              </div>
              <button class="btn btn-primary" onclick="sendRawCoap()">🚀 Send CoAP Message</button>
              <button class="btn" onclick="buildCborPayload()">🔧 Build CBOR</button>
            </div>
          </div>
        </div>

        <!-- Statistics Tab -->
        <div id="statsTab" style="display:none">
          <div class="panel">
            <div class="panel-header">📈 System Statistics</div>
            <div class="panel-content">
              <div class="stats-grid">
                <div class="stat-card">
                  <div class="stat-value" id="totalSids">0</div>
                  <div class="stat-label">Total SID Mappings</div>
                </div>
                <div class="stat-card">
                  <div class="stat-value" id="totalModules">0</div>
                  <div class="stat-label">YANG Modules</div>
                </div>
                <div class="stat-card">
                  <div class="stat-value" id="messagesExchanged">0</div>
                  <div class="stat-label">Messages Exchanged</div>
                </div>
                <div class="stat-card">
                  <div class="stat-value" id="connectionTime">0</div>
                  <div class="stat-label">Connection Time (s)</div>
                </div>
              </div>
              
              <div class="panel" style="margin-top: 1rem;">
                <div class="panel-header">Module Breakdown</div>
                <div class="panel-content">
                  <div id="moduleStats" style="font-family: monospace; font-size: 0.875rem;"></div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- TSN Tab -->
        <div id="tsnTab" style="display:none">
          <div class="panel">
            <div class="panel-header">🔧 TSN Quick Configure</div>
            <div class="panel-content">
              <div style="display:flex; gap:1rem; flex-wrap:wrap;">
                <div style="flex:1; min-width:300px;">
                  <div class="form-group">
                    <label class="form-label">Interface Name</label>
                    <div style="display:flex; gap:0.5rem;">
                      <input class="form-input" id="tsnIface" placeholder="eth0" style="flex:2;">
                      <select class="form-input" id="ifaceSelect" style="flex:2; min-width:180px;">
                        <option value="">(Load interfaces)</option>
                      </select>
                      <button class="btn" onclick="loadInterfaces()" style="flex:1;">Load</button>
                    </div>
                  </div>
                  <div class="form-group">
                    <label class="form-label">PTP Instance</label>
                    <input class="form-input" id="ptpInstance" placeholder="0" value="0">
                  </div>
                </div>
                <div style="flex:2; min-width:320px;">
                  <div class="alert alert-warning">Values map to YANG models. Use presets or edit JSON templates as needed.</div>
                </div>
              </div>

              <div class="panel" style="margin-top:1rem;">
                <div class="panel-header">⏱️ TAS (Time Aware Shaper)</div>
                <div class="panel-content">
                  <div class="form-group">
                    <label class="form-label">Cycle Time (ns)</label>
                    <input class="form-input" id="tasCycleNs" placeholder="1000000" value="1000000">
                  </div>
                  <div class="form-group">
                    <label class="form-label">Admin Base Time (ns since epoch)</label>
                    <input class="form-input" id="tasBaseTimeNs" placeholder="0" value="0">
                    <small class="text-muted">0 = now on device</small>
                  </div>
                  <div class="form-group">
                    <label class="form-label">Gate States (hex mask per entry, comma-separated)</label>
                    <input class="form-input" id="tasGates" placeholder="FF,FF,FF">
                  </div>
                  <button class="btn btn-primary" onclick="applyTAS()">Apply TAS</button>
                </div>
              </div>

              <div class="panel">
                <div class="panel-header">📦 CBS (Credit Based Shaper)</div>
                <div class="panel-content">
                  <div class="form-group">
                    <label class="form-label">Class (0-7)</label>
                    <input class="form-input" id="cbsClass" placeholder="3" value="3">
                  </div>
                  <div class="form-group">
                    <label class="form-label">Idle Slope (kbps)</label>
                    <input class="form-input" id="cbsIdleSlope" placeholder="100000">
                  </div>
                  <div class="form-group">
                    <label class="form-label">Send Slope (kbps)</label>
                    <input class="form-input" id="cbsSendSlope" placeholder="-100000">
                  </div>
                  <button class="btn btn-primary" onclick="applyCBS()">Apply CBS</button>
                </div>
              </div>

              <div class="panel">
                <div class="panel-header">🕒 PTP</div>
                <div class="panel-content">
                  <div class="form-group">
                    <label class="form-label">Domain Number</label>
                    <input class="form-input" id="ptpDomain" placeholder="0" value="0">
                  </div>
                  <div class="form-group">
                    <label class="form-label">Two-Step</label>
                    <select class="form-input" id="ptpTwoStep">
                      <option value="true">true</option>
                      <option value="false">false</option>
                    </select>
                  </div>
                  <button class="btn btn-primary" onclick="applyPTP()">Apply PTP</button>
                </div>
              </div>

              <div class="panel">
                <div class="panel-header">🛡️ PSFP – Flow Meter</div>
                <div class="panel-content">
                  <div class="form-group">
                    <label class="form-label">Flow Meter ID</label>
                    <input class="form-input" id="psfpFmId" placeholder="1" value="1">
                  </div>
                  <div class="form-group">
                    <label class="form-label">Committed Information Rate (kbps)</label>
                    <input class="form-input" id="psfpCir" placeholder="100000">
                  </div>
                  <div class="form-group">
                    <label class="form-label">Committed Burst Size (bytes)</label>
                    <input class="form-input" id="psfpCbs" placeholder="8192">
                  </div>
                  <div class="form-group">
                    <label class="form-label">Excess Information Rate (kbps)</label>
                    <input class="form-input" id="psfpEir" placeholder="0">
                  </div>
                  <div class="form-group">
                    <label class="form-label">Excess Burst Size (bytes)</label>
                    <input class="form-input" id="psfpEbs" placeholder="0">
                  </div>
                  <div class="form-group">
                    <label class="form-label">Drop on Yellow</label>
                    <select class="form-input" id="psfpDropYellow"><option value="false">false</option><option value="true">true</option></select>
                  </div>
                  <button class="btn btn-primary" onclick="applyPSFPFlowMeter()">Apply Flow Meter</button>
                </div>
              </div>

              <div class="panel">
                <div class="panel-header">🧩 PSFP – Stream Filter</div>
                <div class="panel-content">
                  <div class="form-group">
                    <label class="form-label">Stream Filter ID</label>
                    <input class="form-input" id="psfpSfId" placeholder="1" value="1">
                  </div>
                  <div class="form-group">
                    <label class="form-label">Stream Handle</label>
                    <input class="form-input" id="psfpStreamHandle" placeholder="1">
                  </div>
                  <div class="form-group">
                    <label class="form-label">Priority (0-7)</label>
                    <input class="form-input" id="psfpPriority" placeholder="3" value="3">
                  </div>
                  <div class="form-group">
                    <label class="form-label">Max SDU Size (bytes)</label>
                    <input class="form-input" id="psfpMaxSdu" placeholder="1500" value="1500">
                  </div>
                  <div class="form-group">
                    <label class="form-label">Oversize Block Enable</label>
                    <select class="form-input" id="psfpOversizeEnable"><option value="false">false</option><option value="true">true</option></select>
                  </div>
                  <div class="form-group">
                    <label class="form-label">Flow Meter Enable</label>
                    <select class="form-input" id="psfpFmEnable"><option value="false">false</option><option value="true">true</option></select>
                  </div>
                  <div class="form-group">
                    <label class="form-label">Flow Meter Ref (ID)</label>
                    <input class="form-input" id="psfpFmRef" placeholder="1">
                  </div>
                  <div class="form-group">
                    <label class="form-label">Stream Gate Ref (ID)</label>
                    <input class="form-input" id="psfpSgRef" placeholder="1">
                  </div>
                  <button class="btn btn-primary" onclick="applyPSFPStreamFilter()">Apply Stream Filter</button>
                </div>
              </div>

              <div class="panel">
                <div class="panel-header">🚪 PSFP – Stream Gate</div>
                <div class="panel-content">
                  <div class="form-group">
                    <label class="form-label">Stream Gate ID</label>
                    <input class="form-input" id="psfpSgId" placeholder="1" value="1">
                  </div>
                  <div class="form-group">
                    <label class="form-label">Admin Base Time (sec/ns)</label>
                    <div style="display:flex; gap:0.5rem;">
                      <input class="form-input" id="psfpSgBaseSec" placeholder="0" value="0" style="flex:1;">
                      <input class="form-input" id="psfpSgBaseNs" placeholder="0" value="0" style="flex:1;">
                    </div>
                  </div>
                  <div class="form-group">
                    <label class="form-label">Cycle Time (num/den)</label>
                    <div style="display:flex; gap:0.5rem;">
                      <input class="form-input" id="psfpSgCycleNum" placeholder="1" value="1" style="flex:1;">
                      <input class="form-input" id="psfpSgCycleDen" placeholder="1" value="1" style="flex:1;">
                    </div>
                  </div>
                  <div class="form-group">
                    <label class="form-label">Admin Gate States (hex mask)</label>
                    <input class="form-input" id="psfpSgStates" placeholder="FF">
                  </div>
                  <button class="btn btn-primary" onclick="applyPSFPStreamGate()">Apply Stream Gate</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script src="js/sid-mapping.js"></script>
<script src="js/yang-tree-builder.js"></script>
<script>
// Complete implementation with enhanced features
// All protocol handlers, UI management, and communication logic integrated
</script>
 </body>
 </html>

.status-dot.connected {
  background: var(--success);
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

/* Main Layout */
.container {
  display: flex;
  height: calc(100vh - 60px);
}

/* Sidebar */
.sidebar {
  width: 250px;
  background: var(--bg-secondary);
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
}

.sidebar-header {
  padding: 1rem;
  border-bottom: 1px solid var(--border);
  font-weight: 600;
}

.tree-view {
  flex: 1;
  overflow-y: auto;
  padding: 0.5rem;
}

.tree-item {
  padding: 0.5rem;
  cursor: pointer;
  border-radius: 0.25rem;
  margin-bottom: 0.25rem;
  font-size: 0.875rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.tree-item:hover {
  background: var(--bg-hover);
}

.tree-item.selected {
  background: var(--accent);
  color: white;
}

.tree-icon {
  width: 16px;
  height: 16px;
  opacity: 0.6;
}

/* Main Content */
.main {
  flex: 1;
  display: flex;
  flex-direction: column;
}

.tabs {
  display: flex;
  gap: 0.5rem;
  padding: 1rem;
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border);
}

.tab {
  padding: 0.5rem 1rem;
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 0.5rem 0.5rem 0 0;
  cursor: pointer;
  font-size: 0.875rem;
  transition: all 0.2s;
}

.tab.active {
  background: var(--accent);
  border-color: var(--accent);
  color: white;
}

.content {
  flex: 1;
  padding: 1rem;
  overflow-y: auto;
}

.panel {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 0.5rem;
  margin-bottom: 1rem;
}

.panel-header {
  padding: 1rem;
  border-bottom: 1px solid var(--border);
  font-weight: 600;
  background: var(--bg-hover);
  border-radius: 0.5rem 0.5rem 0 0;
}

.panel-content {
  padding: 1rem;
}

.log {
  background: var(--code-bg);
  border: 1px solid var(--border);
  border-radius: 0.5rem;
  height: 300px;
  overflow-y: auto;
  font-family: 'Monaco', 'Menlo', monospace;
  font-size: 0.75rem;
  padding: 0.5rem;
}

.log-entry {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.25rem 0;
  border-bottom: 1px solid rgba(45, 55, 72, 0.3);
}

.log-time {
  color: var(--text-muted);
  min-width: 80px;
}

.log-direction {
  min-width: 40px;
  padding: 0.125rem 0.25rem;
  border-radius: 0.25rem;
  font-size: 0.625rem;
  font-weight: 600;
}

.log-direction.send { background: var(--accent); }
.log-direction.recv { background: var(--success); }

.log-type {
  min-width: 60px;
  color: var(--accent);
  font-weight: 600;
}

.log-data {
  color: var(--text-secondary);
  font-family: monospace;
  word-break: break-all;
}

.form-group {
  margin-bottom: 1rem;
}

.form-label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: 600;
  color: var(--text-secondary);
}

.form-input {
  width: 100%;
  padding: 0.75rem;
  background: var(--bg-primary);
  border: 1px solid var(--border);
  border-radius: 0.5rem;
  color: var(--text-primary);
  font-family: inherit;
}

.form-input:focus {
  outline: none;
  border-color: var(--accent);
}

textarea.form-input {
  min-height: 120px;
  resize: vertical;
  font-family: monospace;
}

select.form-input {
  cursor: pointer;
}

.alert {
  padding: 1rem;
  border-radius: 0.5rem;
  margin-bottom: 1rem;
}

.alert-error {
  background: rgba(239, 68, 68, 0.1);
  border: 1px solid rgba(239, 68, 68, 0.3);
  color: #fca5a5;
}

.alert-success {
  background: rgba(16, 185, 129, 0.1);
  border: 1px solid rgba(16, 185, 129, 0.3);
  color: #6ee7b7;
}

.alert-warning {
  background: rgba(245, 158, 11, 0.1);
  border: 1px solid rgba(245, 158, 11, 0.3);
  color: #fcd34d;
}

.sidebar::-webkit-scrollbar,
.tree-view::-webkit-scrollbar,
.log::-webkit-scrollbar,
.content::-webkit-scrollbar {
  width: 6px;
}

.sidebar::-webkit-scrollbar-track,
.tree-view::-webkit-scrollbar-track,
.log::-webkit-scrollbar-track,
.content::-webkit-scrollbar-track {
  background: var(--bg-primary);
}

.sidebar::-webkit-scrollbar-thumb,
.tree-view::-webkit-scrollbar-thumb,
.log::-webkit-scrollbar-thumb,
.content::-webkit-scrollbar-thumb {
  background: var(--border);
  border-radius: 3px;
}

.sidebar::-webkit-scrollbar-thumb:hover,
.tree-view::-webkit-scrollbar-thumb:hover,
.log::-webkit-scrollbar-thumb:hover,
.content::-webkit-scrollbar-thumb:hover {
  background: var(--text-muted);
}
</style>
</head>
<body>
  <div class="header">
    <div class="logo">🚀 VelocityDRIVE-SP Web Control</div>
    <div class="status" id="connectionStatus">
      <div class="status-dot" id="statusDot"></div>
      <span id="statusText">Disconnected</span>
    </div>
    <button class="btn btn-primary" id="connectBtn" onclick="connectDevice()">Connect</button>
    <button class="btn btn-danger" id="disconnectBtn" onclick="disconnectDevice()" style="display:none;">Disconnect</button>
  </div>

  <div class="container">
    <div class="sidebar">
      <div class="sidebar-header">YANG Tree Browser</div>
      <div class="tree-view" id="yangTree">
        <!-- Dynamic YANG tree will be populated here -->
        <div class="tree-loading">🔄 Loading YANG modules...</div>
      </div>
    </div>

    <div class="main">
      <div class="tabs">
        <div class="tab active" data-tab="monitor">Monitor</div>
        <div class="tab" data-tab="config">Configuration</div>
        <div class="tab" data-tab="raw">Raw CoAP</div>
        <div class="tab" data-tab="test">Test</div>
      </div>

      <div class="content">
        <!-- Monitor Tab -->
        <div id="monitorTab">
          <div class="panel">
            <div class="panel-header">Communication Log</div>
            <div class="panel-content">
              <div class="log" id="logOutput"></div>
            </div>
          </div>
        </div>

        <!-- Configuration Tab -->
        <div id="configTab" style="display:none">
          <div class="panel">
            <div class="panel-header">Configuration Manager</div>
            <div class="panel-content">
              <div class="form-group">
                <label class="form-label">YANG Path</label>
                <input type="text" class="form-input" id="configPath" readonly>
              </div>
              <div class="form-group">
                <button class="btn btn-primary" onclick="getConfig()">Get Configuration</button>
                <button class="btn btn-primary" onclick="setConfig()">Set Configuration</button>
              </div>
              <div class="form-group">
                <label class="form-label">Configuration Data (JSON)</label>
                <textarea class="form-input" id="configData" placeholder='{"enabled": true, "name": "eth0"}'></textarea>
              </div>
            </div>
          </div>
        </div>

        <!-- Test Tab -->
        <div id="testTab" style="display:none">
          <div class="panel">
            <div class="panel-header">CoAP Communication Test</div>
            <div class="panel-content">
              <div class="form-group">
                <button class="btn btn-primary" onclick="testCoapMode()">Test CoAP Mode</button>
                <button class="btn btn-primary" onclick="testGetInterfaces()">Test Get Interfaces</button>
                <button class="btn btn-primary" onclick="testGetSystem()">Test Get System</button>
              </div>
              <div class="form-group">
                <label class="form-label">Test Results</label>
                <textarea class="form-input" id="testResults" readonly></textarea>
              </div>
            </div>
          </div>
        </div>

        <!-- Raw CoAP Tab -->
        <div id="rawTab" style="display:none">
          <div class="panel">
            <div class="panel-header">Raw CoAP Message Builder</div>
            <div class="panel-content">
              <div class="form-group">
                <label class="form-label">Method</label>
                <select class="form-input" id="coapMethod">
                  <option value="GET">GET</option>
                  <option value="POST">POST</option>
                  <option value="PUT">PUT</option>
                  <option value="DELETE">DELETE</option>
                </select>
              </div>
              <div class="form-group">
                <label class="form-label">URI Path</label>
                <input type="text" class="form-input" id="coapUri" placeholder="/ietf-interfaces:interfaces">
              </div>
              <div class="form-group">
                <label class="form-label">Payload (CBOR Hex)</label>
                <textarea class="form-input" id="coapPayload" placeholder="A1 19 07F1 F5"></textarea>
              </div>
              <button class="btn btn-primary" onclick="sendRawCoap()">Send CoAP Message</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script src="js/storage.js"></script>
<script src="js/sid-mapping.js"></script>
<script>
// ==================== Global Variables ====================
let port = null;
let reader = null;
let writer = null;
let isConnected = false;
let selectedPath = '';
let messageId = 1;
let coapModeActive = false;
let pendingRequests = new Map();

// ==================== MUP1 Protocol ====================
class MUP1Protocol {
  createPingFrame() {
    return '>p<<8553\n';
  }

  createCoapInitFrame() {
    return '>c\n';
  }

  createCoapDataFrame(coapMessage) {
    // Convert CoAP binary message to hex string for MUP1 transmission
    const hexData = Array.from(coapMessage)
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
    
    // Calculate checksum (simple XOR for now, might need different algorithm)
    let checksum = 0;
    for (let i = 0; i < coapMessage.length; i++) {
      checksum ^= coapMessage[i];
    }
    const checksumHex = checksum.toString(16).padStart(4, '0');
    
    // Format: >d[HEX_DATA]<<CHECKSUM
    return `>d${hexData}<<${checksumHex}\n`;
  }

  parseFrame(data) {
    if (data.startsWith('>P')) {
      // Ping response
      const parts = data.replace(/^>P/, '').replace(/<<.*$/, '').trim();
      return { type: 'ping-response', data: parts };
    } else if (data.startsWith('>C')) {
      // CoAP mode confirmation
      return { type: 'coap-init-response' };
    } else if (data.startsWith('>D')) {
      // CoAP data response - extract hex data and convert back to binary
      const match = data.match(/>D([0-9a-fA-F]+)<</);
      if (match) {
        const hexData = match[1];
        const binaryData = new Uint8Array(hexData.match(/.{2}/g).map(hex => parseInt(hex, 16)));
        return { type: 'coap-data-response', data: binaryData };
      }
    } else if (data.startsWith('>T')) {
      // Trace response
      return { type: 'trace-response', data: data };
    }
    return { type: 'unknown', data: data };
  }
}

// ==================== CoAP Protocol ====================
class CoapProtocol {
  constructor() {
    this.messageId = 1;
  }

  buildMessage(method, uri, payload = null) {
    // Reset option number tracking for each new message
    this._lastOptionNumber = 0;
    const methodCode = {
      'GET': 0x01,
      'POST': 0x02,  
      'PUT': 0x03,
      'DELETE': 0x04
    }[method] || 0x01;

    // Header: Ver=1, Type=0 (CON), TKL=0
    const header = new Uint8Array([
      0x40, // Ver=1, Type=0 (CON), TKL=0
      methodCode,
      (this.messageId >> 8) & 0xFF,
      this.messageId & 0xFF
    ]);
    this.messageId++;

    // Build options array
    const options = [];

    // CORECONF implementation according to RFC 9254
    // For CORECONF, we need: /.well-known/coreconf/data/<sid>
    
    // Add Uri-Path: .well-known (Option 11, Delta=11, Length=11)
    const wellKnownBytes = new TextEncoder().encode('.well-known');
    this._addOption(options, 11, wellKnownBytes);

    // Add Uri-Path: coreconf (Option 11, Delta=0, Length=8) 
    const coreconfBytes = new TextEncoder().encode('coreconf');
    this._addOption(options, 11, coreconfBytes);

    // Add Uri-Path: data (Option 11, Delta=0, Length=4)
    const dataBytes = new TextEncoder().encode('data');
    this._addOption(options, 11, dataBytes);

    // Convert YANG path to SID for CORECONF
    if (uri && uri !== '/') {
      const yangPath = uri.replace(/^\//, '');
      if (yangPath && window.yangToSidMap && window.yangToSidMap[yangPath]) {
        const sid = window.yangToSidMap[yangPath];
        const sidBytes = new TextEncoder().encode(sid.toString());
        this._addOption(options, 11, sidBytes);
      } else if (yangPath) {
        // Fallback: use path segments if SID mapping not found
        console.warn('SID mapping not found for:', yangPath);
        const segments = yangPath.split('/').filter(s => s);
        for (const segment of segments) {
          const segmentBytes = new TextEncoder().encode(segment);
          this._addOption(options, 11, segmentBytes);
        }
      }
    }

    // Add Content-Format for CORECONF CBOR (Option 12)
    if (payload) {
      // Content-Format: application/yang-data+cbor (60) per RFC 9254
      this._addOption(options, 12, new Uint8Array([60]));
    }

    // Accept option for response format
    this._addOption(options, 17, new Uint8Array([60])); // Accept: application/yang-data+cbor

    // Combine message parts
    let message = new Uint8Array(header.length + options.length + (payload ? payload.length + 1 : 0));
    message.set(header);
    message.set(new Uint8Array(options), header.length);

    if (payload) {
      message[header.length + options.length] = 0xFF; // Payload marker
      message.set(payload, header.length + options.length + 1);
    }

    return message;
  }

  _addOption(options, optionNumber, value) {
    const lastOptionNumber = this._lastOptionNumber || 0;
    const delta = optionNumber - lastOptionNumber;
    const length = value.length;

    // Encode option header with delta and length
    let header = 0;
    let extraBytes = [];

    // Encode delta
    if (delta < 13) {
      header |= (delta << 4);
    } else if (delta < 269) {
      header |= (13 << 4);
      extraBytes.push(delta - 13);
    } else {
      header |= (14 << 4);
      extraBytes.push((delta - 269) >> 8);
      extraBytes.push((delta - 269) & 0xFF);
    }

    // Encode length
    if (length < 13) {
      header |= length;
    } else if (length < 269) {
      header |= 13;
      extraBytes.push(length - 13);
    } else {
      header |= 14;
      extraBytes.push((length - 269) >> 8);
      extraBytes.push((length - 269) & 0xFF);
    }

    // Add option to array
    options.push(header);
    options.push(...extraBytes);
    options.push(...value);

    this._lastOptionNumber = optionNumber;
  }

  parseMessage(data) {
    if (data.length < 4) return null;

    const version = (data[0] >> 6) & 0x03;
    const type = (data[0] >> 4) & 0x03;
    const tokenLength = data[0] & 0x0F;
    const code = data[1];
    const messageId = (data[2] << 8) | data[3];

    // Find payload marker
    let payloadStart = 4 + tokenLength;
    let payload = null;

    // Skip options to find payload
    let i = 4 + tokenLength;
    while (i < data.length && data[i] !== 0xFF) {
      if (data[i] === 0) break;
      const optionDelta = (data[i] >> 4) & 0x0F;
      const optionLength = data[i] & 0x0F;
      i += 1 + optionLength;
    }

    if (i < data.length && data[i] === 0xFF) {
      payload = data.slice(i + 1);
    }

    return {
      version,
      type,
      tokenLength,
      code: `${(code >> 5)}.${(code & 0x1F).toString().padStart(2, '0')}`,
      messageId,
      payload
    };
  }
}

// ==================== CBOR Codec ====================
class CborCodec {
  encode(obj) {
    const result = [];
    this._encodeValue(obj, result);
    return new Uint8Array(result);
  }

  _encodeValue(value, result) {
    if (value === null || value === undefined) {
      result.push(0xF6); // null
    } else if (typeof value === 'boolean') {
      result.push(value ? 0xF5 : 0xF4); // true/false
    } else if (typeof value === 'number') {
      this._encodeNumber(value, result);
    } else if (typeof value === 'string') {
      this._encodeString(value, result);
    } else if (value instanceof Uint8Array) {
      this._encodeByteString(value, result);
    } else if (Array.isArray(value)) {
      this._encodeArray(value, result);
    } else if (typeof value === 'object') {
      this._encodeObject(value, result);
    } else {
      result.push(0xF6); // fallback to null
    }
  }

  _encodeNumber(num, result) {
    if (num >= 0) {
      // Positive integer (Major Type 0)
      if (num < 24) {
        result.push(num);
      } else if (num < 256) {
        result.push(0x18, num);
      } else if (num < 65536) {
        result.push(0x19, (num >> 8) & 0xFF, num & 0xFF);
      } else {
        result.push(0x1A, (num >> 24) & 0xFF, (num >> 16) & 0xFF, (num >> 8) & 0xFF, num & 0xFF);
      }
    } else {
      // Negative integer (Major Type 1)
      const absValue = Math.abs(num + 1);
      if (absValue < 24) {
        result.push(0x20 | absValue);
      } else if (absValue < 256) {
        result.push(0x38, absValue);
      } else if (absValue < 65536) {
        result.push(0x39, (absValue >> 8) & 0xFF, absValue & 0xFF);
      } else {
        result.push(0x3A, (absValue >> 24) & 0xFF, (absValue >> 16) & 0xFF, (absValue >> 8) & 0xFF, absValue & 0xFF);
      }
    }
  }

  _encodeString(str, result) {
    const bytes = new TextEncoder().encode(str);
    // Major Type 3 (Text String)
    this._encodeLength(0x60, bytes.length, result);
    result.push(...bytes);
  }

  _encodeByteString(bytes, result) {
    // Major Type 2 (Byte String)
    this._encodeLength(0x40, bytes.length, result);
    result.push(...bytes);
  }

  _encodeArray(arr, result) {
    // Major Type 4 (Array)
    this._encodeLength(0x80, arr.length, result);
    for (const item of arr) {
      this._encodeValue(item, result);
    }
  }

  _encodeObject(obj, result) {
    const keys = Object.keys(obj);
    // Major Type 5 (Map)
    this._encodeLength(0xA0, keys.length, result);
    
    for (const key of keys) {
      // Try to encode key as SID integer first
      const sid = parseInt(key);
      if (!isNaN(sid)) {
        this._encodeNumber(sid, result);
      } else {
        this._encodeString(key, result);
      }
      this._encodeValue(obj[key], result);
    }
  }

  _encodeLength(majorType, length, result) {
    if (length < 24) {
      result.push(majorType | length);
    } else if (length < 256) {
      result.push(majorType | 24, length);
    } else if (length < 65536) {
      result.push(majorType | 25, (length >> 8) & 0xFF, length & 0xFF);
    } else {
      result.push(majorType | 26, (length >> 24) & 0xFF, (length >> 16) & 0xFF, (length >> 8) & 0xFF, length & 0xFF);
    }
  }

  decode(data) {
    if (!data || data.length === 0) return null;
    
    let pos = 0;
    
    const readLength = (additionalInfo) => {
      if (additionalInfo < 24) return additionalInfo;
      if (additionalInfo === 24) return data[pos++];
      if (additionalInfo === 25) {
        const result = (data[pos] << 8) | data[pos + 1];
        pos += 2;
        return result;
      }
      if (additionalInfo === 26) {
        const result = (data[pos] << 24) | (data[pos + 1] << 16) | (data[pos + 2] << 8) | data[pos + 3];
        pos += 4;
        return result;
      }
      throw new Error('Unsupported length encoding');
    };
    
    const readValue = () => {
      if (pos >= data.length) return null;
      
      const byte = data[pos++];
      const majorType = byte >> 5;
      const additionalInfo = byte & 0x1F;
      
      switch (majorType) {
        case 0: // Unsigned integer
          return readLength(additionalInfo);
          
        case 1: // Negative integer
          const val = readLength(additionalInfo);
          return -1 - val;
          
        case 2: // Byte string
          const byteLen = readLength(additionalInfo);
          const byteResult = data.slice(pos, pos + byteLen);
          pos += byteLen;
          return byteResult;
          
        case 3: // Text string
          const textLen = readLength(additionalInfo);
          const textBytes = data.slice(pos, pos + textLen);
          pos += textLen;
          return new TextDecoder().decode(textBytes);
          
        case 4: // Array
          const arrayLen = readLength(additionalInfo);
          const arrayResult = [];
          for (let i = 0; i < arrayLen; i++) {
            arrayResult.push(readValue());
          }
          return arrayResult;
          
        case 5: // Map
          const mapLen = readLength(additionalInfo);
          const result = {};
          for (let i = 0; i < mapLen; i++) {
            const key = readValue();
            const value = readValue();
            result[key] = value;
          }
          return result;
          
        case 6: // Semantic tag (ignore tag, decode tagged value)
          readLength(additionalInfo); // Skip tag number
          return readValue(); // Return tagged value
          
        case 7: // Simple/Float
          if (additionalInfo === 20) return false;
          if (additionalInfo === 21) return true;
          if (additionalInfo === 22) return null;
          if (additionalInfo === 23) return undefined;
          break;
      }
      throw new Error(`Unknown CBOR type: ${majorType}, additional info: ${additionalInfo}`);
    };
    
    return readValue();
  }
}

// ==================== Serial Communication ====================
async function connectDevice() {
  try {
    if (!navigator.serial) {
      alert('Web Serial API not supported');
      return;
    }

    port = await navigator.serial.requestPort({
      filters: [{ usbVendorId: 0x04D8 }] // Microchip vendor ID
    });

    await port.open({
      baudRate: 115200,
      dataBits: 8,
      stopBits: 1,
      parity: 'none'
    });

    reader = port.readable.getReader();
    writer = port.writable.getWriter();

    isConnected = true;
    coapModeActive = false;
    updateConnectionStatus();

    // Start reading loop
    readLoop();

    // Send ping to test connection
    await sendPing();

  } catch (error) {
    alert('Connection failed: ' + error.message);
  }
}

async function disconnectDevice() {
  if (reader) {
    await reader.cancel();
    reader = null;
  }
  if (writer) {
    writer.releaseLock();
    writer = null;
  }
  if (port) {
    await port.close();
    port = null;
  }
  
  isConnected = false;
  coapModeActive = false;
  updateConnectionStatus();
}

function updateConnectionStatus() {
  const statusDot = document.getElementById('statusDot');
  const statusText = document.getElementById('statusText');
  const connectBtn = document.getElementById('connectBtn');
  const disconnectBtn = document.getElementById('disconnectBtn');

  if (isConnected) {
    statusDot.classList.add('connected');
    statusText.textContent = 'Connected';
    connectBtn.style.display = 'none';
    disconnectBtn.style.display = 'inline-block';
  } else {
    statusDot.classList.remove('connected');
    statusText.textContent = 'Disconnected';
    connectBtn.style.display = 'inline-block';
    disconnectBtn.style.display = 'none';
  }
}

async function readLoop() {
  const decoder = new TextDecoder();
  let buffer = '';

  while (reader) {
    try {
      const { value, done } = await reader.read();
      if (done) break;

      const text = decoder.decode(value);
      buffer += text;

      // Process complete frames
      while (buffer.includes('\n')) {
        const lineEnd = buffer.indexOf('\n');
        const line = buffer.substring(0, lineEnd);
        buffer = buffer.substring(lineEnd + 1);

        if (line.trim()) {
          await handleReceiveData(new TextEncoder().encode(line + '\n'));
        }
      }
    } catch (error) {
      console.error('Read error:', error);
      break;
    }
  }
}

// ==================== Protocol Handlers ====================
const mup1 = new MUP1Protocol();
const coap = new CoapProtocol();
const cbor = new CborCodec();

async function sendPing() {
  if (!writer) return;
  
  const frame = mup1.createPingFrame();
  await writer.write(new TextEncoder().encode(frame));
  logMessage('SEND', 'PING', 0, frame.length, 'Device ping');
}

async function enterCoapMode() {
  if (coapModeActive || !writer) return;

  const frame = mup1.createCoapInitFrame();
  await writer.write(new TextEncoder().encode(frame));
  
  // Wait for mode change
  await new Promise(resolve => setTimeout(resolve, 200));
  
  coapModeActive = true;
  logMessage('SEND', 'COAP_INIT', 0, frame.length, 'Entering CoAP mode');
  
  return true;
}

async function sendCoapRequest(method, uri, payload = null) {
  await enterCoapMode();
  
  const message = coap.buildMessage(method, uri, payload);
  const mup1Frame = mup1.createCoapDataFrame(message);
  await writer.write(new TextEncoder().encode(mup1Frame));
  
  logMessage('SEND', method, coap.messageId - 1, mup1Frame.length, `${method} ${uri} (MUP1 wrapped)`);
  
  // Store pending request for response matching
  const requestId = coap.messageId - 1;
  pendingRequests.set(requestId, { method, uri, timestamp: Date.now() });
  
  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      pendingRequests.delete(requestId);
      reject(new Error('Request timeout'));
    }, 10000);
    
    // Store the resolve/reject functions for this request
    pendingRequests.get(requestId).resolve = resolve;
    pendingRequests.get(requestId).reject = reject;
    pendingRequests.get(requestId).timeout = timeout;
  });
}

async function handleReceiveData(data) {
  if (coapModeActive) {
    // In CoAP mode, expect MUP1-wrapped CoAP responses
    try {
      const textData = new TextDecoder().decode(data);
      const mup1Response = mup1.parseFrame(textData);
      
      if (mup1Response.type === 'coap-data-response') {
        // Extract binary CoAP data from MUP1 frame
        const coapBinaryData = mup1Response.data;
        const response = coap.parseMessage(coapBinaryData);
        
        if (response && response.messageId !== undefined) {
          // Find matching request
          const request = pendingRequests.get(response.messageId);
          if (request) {
            clearTimeout(request.timeout);
            pendingRequests.delete(response.messageId);
            
            logMessage('RECV', 'COAP_RESP', response.messageId, coapBinaryData.length, 
                      `Code: ${response.code}, Payload: ${response.payload ? response.payload.length + ' bytes' : 'none'}`);
            
            if (request.resolve) {
              request.resolve(response);
            }
          } else {
            logMessage('RECV', 'COAP_RESP', response.messageId, coapBinaryData.length, 'Unmatched response');
          }
        }
      } else {
        // Handle other MUP1 frame types (ping, etc.)
        logMessage('RECV', 'MUP1_FRAME', null, textData.length, `Type: ${mup1Response.type}`);
      }
    } catch (error) {
      console.warn('Failed to parse MUP1/CoAP response:', error);
      logMessage('RECV', 'RAW_DATA', null, data.length, 'Failed to parse (binary/text data)');
    }
  } else {
    // In MUP1 mode, parse text frames
    const text = new TextDecoder().decode(data);
    const frame = mup1.parseFrame(text);

    if (frame.type === 'ping-response') {
      const info = frame.data.split(' ');
      logMessage('RECV', 'PING_RESP', null, data.length, `Device: ${info[0]}`);
    } else if (frame.type === 'coap-init-response') {
      logMessage('RECV', 'COAP_INIT', null, data.length, 'CoAP mode acknowledged');
    } else {
      logMessage('RECV', 'DATA', null, data.length, text.trim());
    }
  }
}

// ==================== Test Functions ====================
async function testCoapMode() {
  if (!isConnected) {
    alert('Please connect to device first');
    return;
  }

  const results = document.getElementById('testResults');
  results.value = 'Testing CoAP mode...\n';

  try {
    await enterCoapMode();
    results.value += 'CoAP mode activated successfully\n';
    results.value += `CoAP Mode Active: ${coapModeActive}\n`;
  } catch (error) {
    results.value += `Error: ${error.message}\n`;
  }
}

async function testGetInterfaces() {
  if (!isConnected) {
    alert('Please connect to device first');
    return;
  }

  const results = document.getElementById('testResults');
  results.value = 'Testing GET interfaces...\n';

  try {
    const response = await sendCoapRequest('GET', '/ietf-interfaces:interfaces');
    results.value += `Response Code: ${response.code}\n`;
    results.value += `Payload Length: ${response.payload ? response.payload.length : 0}\n`;
    
    if (response.payload) {
      const decoded = cbor.decode(response.payload);
      results.value += `Decoded Data: ${JSON.stringify(decoded, null, 2)}\n`;
    }
  } catch (error) {
    results.value += `Error: ${error.message}\n`;
  }
}

async function testGetSystem() {
  if (!isConnected) {
    alert('Please connect to device first');
    return;
  }

  const results = document.getElementById('testResults');
  results.value = 'Testing GET system...\n';

  try {
    const response = await sendCoapRequest('GET', '/ietf-system:system');
    results.value += `Response Code: ${response.code}\n`;
    results.value += `Payload Length: ${response.payload ? response.payload.length : 0}\n`;
  } catch (error) {
    results.value += `Error: ${error.message}\n`;
  }
}

// ==================== Configuration Functions ====================
async function getConfig() {
  if (!isConnected || !selectedPath) {
    alert('Please connect device and select a path');
    return;
  }

  try {
    const response = await sendCoapRequest('GET', selectedPath);
    
    if (response.payload) {
      const decoded = cbor.decode(response.payload);
      const mapped = mapSidsToYang(decoded);
      document.getElementById('configData').value = JSON.stringify(mapped, null, 2);
    }
  } catch (error) {
    alert('Failed to get configuration: ' + error.message);
  }
}

async function setConfig() {
  if (!isConnected || !selectedPath) {
    alert('Please connect device and select a path');
    return;
  }

  try {
    const configData = document.getElementById('configData').value;
    const jsonData = JSON.parse(configData);
    const sidData = yangToSid(jsonData);
    const cborPayload = cbor.encode(sidData);
    
    const response = await sendCoapRequest('PUT', selectedPath, cborPayload);
    alert('Configuration updated successfully');
  } catch (error) {
    alert('Failed to set configuration: ' + error.message);
  }
}

// ==================== Raw CoAP Functions ====================
async function sendRawCoap() {
  if (!isConnected) {
    alert('Please connect device first');
    return;
  }

  const method = document.getElementById('coapMethod').value;
  const uri = document.getElementById('coapUri').value;
  const payloadHex = document.getElementById('coapPayload').value.trim();

  let payload = null;
  if (payloadHex) {
    try {
      const hexBytes = payloadHex.replace(/\s+/g, '').match(/.{2}/g);
      payload = new Uint8Array(hexBytes.map(h => parseInt(h, 16)));
    } catch (error) {
      alert('Invalid CBOR hex payload');
      return;
    }
  }

  try {
    const response = await sendCoapRequest(method, uri, payload);
    logMessage('INFO', 'COAP_RESP', null, 0, `Response: ${response.code}`);
  } catch (error) {
    alert('CoAP request failed: ' + error.message);
  }
}

// ==================== Utility Functions ====================
function logMessage(direction, type, msgId, length, data) {
  const logOutput = document.getElementById('logOutput');
  const time = new Date().toLocaleTimeString();
  const entry = document.createElement('div');
  entry.className = 'log-entry';

  entry.innerHTML = `
    <span class="log-time">${time}</span>
    <span class="log-direction ${direction.toLowerCase()}">${direction}</span>
    <span class="log-type">${type}</span>
    <span class="log-data">${msgId ? `[${msgId}] ` : ''}(${length}B) ${data}</span>
  `;

  logOutput.appendChild(entry);
  logOutput.scrollTop = logOutput.scrollHeight;
}

// SID Mapping Functions
function yangToSid(data) {
  if (!data || typeof data !== 'object') return data;
  
  const result = {};
  
  function convertPath(path, value) {
    // Direct SID lookup for YANG paths
    if (window.yangToSidMap && window.yangToSidMap[path]) {
      return { [window.yangToSidMap[path]]: value };
    }
    
    // Try to find partial matches for nested structures
    let bestMatch = null;
    let bestMatchLength = 0;
    
    if (window.yangToSidMap) {
      for (const [yangPath, sid] of Object.entries(window.yangToSidMap)) {
        if (yangPath === path) {
          return { [sid]: value };
        }
        // Check if this YANG path is a parent/child of the current path
        if (path.startsWith(yangPath + '/') || yangPath.startsWith(path + '/')) {
          if (yangPath.length > bestMatchLength) {
            bestMatch = sid;
            bestMatchLength = yangPath.length;
          }
        }
      }
    }
    
    if (bestMatch) {
      return { [bestMatch]: value };
    }
    
    // Fallback: use path as key if no SID found
    console.warn('No SID mapping found for YANG path:', path);
    return { [path]: value };
  }
  
  for (const [path, value] of Object.entries(data)) {
    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
      // Recursively convert nested objects
      const convertedNested = yangToSid(value);
      Object.assign(result, convertedNested);
    } else {
      const converted = convertPath(path, value);
      Object.assign(result, converted);
    }
  }
  
  return result;
}

function mapSidsToYang(data) {
  if (!data || typeof data !== 'object') return data;
  
  const result = {};
  
  function convertSidToPath(sid, value) {
    // Convert SID back to YANG path
    const yangPath = window.yangSidMap?.[sid];
    if (yangPath) {
      return { [yangPath]: value };
    }
    
    // If no mapping found, keep the SID as key
    console.warn('No YANG path mapping found for SID:', sid);
    return { [sid]: value };
  }
  
  for (const [key, value] of Object.entries(data)) {
    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
      // Recursively convert nested objects
      const convertedNested = mapSidsToYang(value);
      Object.assign(result, convertedNested);
    } else {
      const converted = convertSidToPath(key, value);
      Object.assign(result, converted);
    }
  }
  
  return result;
}

// ==================== Tab Management ====================
document.querySelectorAll('.tab').forEach(tab => {
  tab.addEventListener('click', () => {
    // Update tab appearance
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    tab.classList.add('active');

    // Show corresponding content
    document.querySelectorAll('#monitorTab, #configTab, #rawTab, #testTab').forEach(content => {
      content.style.display = 'none';
    });

    const tabName = tab.dataset.tab;
  document.getElementById(tabName + 'Tab').style.display = 'block';
  });
});

// Tree item selection
document.querySelectorAll('.tree-item').forEach(item => {
  item.addEventListener('click', () => {
    document.querySelectorAll('.tree-item').forEach(i => i.classList.remove('selected'));
    item.classList.add('selected');
    selectedPath = item.dataset.path;
    document.getElementById('configPath').value = selectedPath;
  });
});

// Statistics update function
function updateStatistics() {
  if (window.yangSidMap) {
    document.getElementById('totalSids').textContent = Object.keys(window.yangSidMap).length;
  }
  
  if (window.moduleStats) {
    const totalModules = Object.keys(window.moduleStats).filter(module => window.moduleStats[module] > 0).length;
    document.getElementById('totalModules').textContent = totalModules;
    
    // Update module breakdown
    const moduleStatsDiv = document.getElementById('moduleStats');
    if (moduleStatsDiv) {
      const statsText = Object.entries(window.moduleStats)
        .filter(([module, count]) => count > 0)
        .sort(([,a], [,b]) => b - a)
        .map(([module, count]) => `${module}: ${count} mappings`)
        .join('\n');
      moduleStatsDiv.textContent = statsText;
    }
  }
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
  logMessage('INFO', 'INIT', null, 0, 'VelocityDRIVE-SP Web Control initialized');
  // Try to load user SID map override from storage
  try {
    const stored = window.SIDStorage?.load && window.SIDStorage.load();
    if (stored && Object.keys(stored).length > 0) {
      window.yangSidMap = stored;
      logMessage('INFO', 'SID', null, 0, `Loaded custom SID map: ${Object.keys(stored).length} entries`);
    }
  } catch (e) {
    console.warn('SID storage load failed:', e);
  }

  // If no mapping yet, try auto-load from configurable sources
  if ((!window.yangSidMap || Object.keys(window.yangSidMap).length === 0)) {
    autoLoadCoreconf()
      .then(loaded => {
        if (loaded) logMessage('INFO', 'SID', null, 0, `Auto-fetched coreconf: ${Object.keys(window.yangSidMap).length} entries`);
      })
      .catch(err => console.warn('Auto coreconf load failed:', err));
  }

  // Staleness check: if cached mapping older than 7 days, refresh in background
  try {
    const last = parseInt(localStorage.getItem('velocitydrivesp_sid_last_updated') || '0', 10);
    const weekMs = 7 * 24 * 60 * 60 * 1000;
    if (last > 0 && Date.now() - last > weekMs) {
      autoLoadCoreconf().catch(() => {});
    }
  } catch {}
  
  // Initialize YANG Tree Browser
  if (window.yangSidMap && window.YangTreeBuilder) {
    const treeBuilder = new YangTreeBuilder(window.yangSidMap);
    treeBuilder.renderTree('yangTree');
    logMessage('INFO', 'INIT', null, 0, `YANG tree loaded with ${Object.keys(window.yangSidMap).length} SID mappings`);
    
    // Set up statistics
    if (window.moduleStats) {
      updateStatistics();
    }
  }
  
  // Set up global path selection function for tree builder
  window.selectYangPath = (path, sid) => {
    selectedPath = path;
    selectedSid = sid;
    document.getElementById('configPath').value = path;
    logMessage('INFO', 'SELECT', sid, path.length, `Selected: ${path}`);
  };

  // Expose import/export utilities
  window.onImportSidFile = async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    try {
      const text = await file.text();
      const map = window.SIDStorage.parse(text);
      if (!map || typeof map !== 'object') throw new Error('Invalid mapping object');
      window.SIDStorage.save(map);
      window.yangSidMap = map;
      // Re-render tree
      if (window.YangTreeBuilder) {
        const treeBuilder = new YangTreeBuilder(window.yangSidMap);
        treeBuilder.renderTree('yangTree');
      }
      updateStatistics?.();
      logMessage('INFO', 'SID', null, 0, `Imported SID map (${Object.keys(map).length} entries)`);
    } catch (err) {
      console.error(err);
      alert('Failed to import SID mapping: ' + err.message);
    } finally {
      // reset file input
      e.target.value = '';
    }
  };

  window.exportSidMap = () => {
    try {
      const map = window.yangSidMap || {};
      const content = JSON.stringify(map, null, 2);
      window.SIDStorage.download('yang-sid-map.json', content);
      logMessage('INFO', 'SID', null, 0, 'Exported SID map');
    } catch (e) {
      alert('Failed to export SID mapping');
    }
  };

  window.onImportCoreconfFolder = async (e) => {
    const files = e.target.files;
    if (!files || files.length === 0) return;
    try {
      if (!window.SIDStorage?.fromFileList) throw new Error('Importer not loaded');
      const { mapping, moduleStats } = await window.SIDStorage.fromFileList(files);
      if (!mapping || Object.keys(mapping).length === 0) throw new Error('No mappings parsed');
      window.SIDStorage.save(mapping);
      window.yangSidMap = mapping;
      window.moduleStats = moduleStats;
      if (window.YangTreeBuilder) {
        const treeBuilder = new YangTreeBuilder(window.yangSidMap);
        treeBuilder.renderTree('yangTree');
      }
      updateStatistics?.();
      logMessage('INFO', 'SID', null, 0, `Imported coreconf folder: ${Object.keys(mapping).length} entries`);
    } catch (err) {
      console.error(err);
      alert('Failed to import coreconf folder: ' + err.message);
    } finally {
      e.target.value = '';
    }
  };

  window.resetSidMap = () => {
    try {
      localStorage.removeItem(window.SIDStorage.STORAGE_KEY_SID);
      // Reload to built-in mapping
      location.reload();
    } catch (e) {
      location.reload();
    }
  };

  // Load interfaces via CORECONF GET and populate dropdown
  window.loadInterfaces = async () => {
    try {
      if (!isConnected) return alert('Connect to device first');
      const resp = await sendCoapRequest('GET', '/ietf-interfaces:interfaces');
      if (!resp.payload) return alert('No data');
      const decoded = cbor.decode(resp.payload);
      const mapped = mapSidsToYang(decoded);
      const names = [];
      for (const [k, v] of Object.entries(mapped)) {
        if (typeof v === 'string' && k.endsWith('/ietf-interfaces:interfaces/interface/name')) {
          names.push(v);
        }
      }
      const sel = document.getElementById('ifaceSelect');
      sel.innerHTML = '';
      if (names.length === 0) {
        const opt = document.createElement('option');
        opt.value = '';
        opt.textContent = '(No interfaces)';
        sel.appendChild(opt);
      } else {
        const ph = document.createElement('option');
        ph.value = '';
        ph.textContent = '(Select interface)';
        sel.appendChild(ph);
        names.sort().forEach(n => {
          const opt = document.createElement('option');
          opt.value = n;
          opt.textContent = n;
          sel.appendChild(opt);
        });
      }
      sel.onchange = () => {
        if (sel.value) document.getElementById('tsnIface').value = sel.value;
      };
      logMessage('INFO', 'IFACES', null, names.length, `Loaded: ${names.join(', ')}`);
    } catch (e) {
      alert('Failed to load interfaces: ' + e.message);
    }
  };

  // Touch mode toggler and auto-detect for touch devices
  window.toggleTouchMode = () => {
    document.documentElement.classList.toggle('touch-mode');
  };
  try {
    if (window.matchMedia && window.matchMedia('(pointer: coarse)').matches) {
      document.documentElement.classList.add('touch-mode');
    }
  } catch {}

  // -------- PSFP Apply Handlers --------
  function psfpBase() {
    return '/ieee802-dot1q-bridge:bridges/bridge/component/ieee802-dot1q-psfp-bridge:';
  }

  window.applyPSFPFlowMeter = async () => {
    try {
      const id = parseInt(document.getElementById('psfpFmId').value || '0', 10);
      const cir = parseInt(document.getElementById('psfpCir').value || '0', 10);
      const cbs = parseInt(document.getElementById('psfpCbs').value || '0', 10);
      const eir = parseInt(document.getElementById('psfpEir').value || '0', 10);
      const ebs = parseInt(document.getElementById('psfpEbs').value || '0', 10);
      const dropY = document.getElementById('psfpDropYellow').value === 'true';

      const base = psfpBase() + 'flow-meters/flow-meter-instance-table';
      const yang = {};
      yang[base + '/flow-meter-instance-id'] = id;
      if (!isNaN(cir)) yang[base + '/committed-information-rate'] = cir;
      if (!isNaN(cbs)) yang[base + '/committed-burst-size'] = cbs;
      if (!isNaN(eir)) yang[base + '/excess-information-rate'] = eir;
      if (!isNaN(ebs)) yang[base + '/excess-burst-size'] = ebs;
      yang[base + '/drop-on-yellow'] = dropY;

      const sidObj = yangToSid(yang);
      const payload = cbor.encode(sidObj);
      const resp = await sendCoapRequest('PUT', base, payload);
      alert(`Flow meter updated (code ${resp.code})`);
    } catch (e) {
      alert('Failed to apply Flow Meter: ' + e.message);
    }
  };

  window.applyPSFPStreamFilter = async () => {
    try {
      const id = parseInt(document.getElementById('psfpSfId').value || '0', 10);
      const handle = parseInt(document.getElementById('psfpStreamHandle').value || '0', 10);
      const prio = parseInt(document.getElementById('psfpPriority').value || '0', 10);
      const maxsdu = parseInt(document.getElementById('psfpMaxSdu').value || '0', 10);
      const oversz = document.getElementById('psfpOversizeEnable').value === 'true';
      const fmEn = document.getElementById('psfpFmEnable').value === 'true';
      const fmRef = parseInt(document.getElementById('psfpFmRef').value || '0', 10);
      const sgRef = parseInt(document.getElementById('psfpSgRef').value || '0', 10);

      const base = psfpBase() + 'stream-filters/stream-filter-instance-table';
      const yang = {};
      yang[base + '/stream-filter-instance-id'] = id;
      if (!isNaN(handle)) yang[base + '/stream-handle-spec/stream-handle/stream-handle'] = handle;
      if (!isNaN(prio)) yang[base + '/priority-spec'] = prio;
      if (!isNaN(maxsdu)) yang[base + '/max-sdu-size'] = maxsdu;
      yang[base + '/stream-blocked-due-to-oversize-frame-enabled'] = oversz;
      yang[base + '/flow-meter-enable'] = fmEn;
      if (!isNaN(fmRef)) yang[base + '/flow-meter-ref'] = fmRef;
      if (!isNaN(sgRef)) yang[base + '/stream-gate-ref'] = sgRef;

      const sidObj = yangToSid(yang);
      const payload = cbor.encode(sidObj);
      const resp = await sendCoapRequest('PUT', base, payload);
      alert(`Stream filter updated (code ${resp.code})`);
    } catch (e) {
      alert('Failed to apply Stream Filter: ' + e.message);
    }
  };

  window.applyPSFPStreamGate = async () => {
    try {
      const id = parseInt(document.getElementById('psfpSgId').value || '0', 10);
      const sec = parseInt(document.getElementById('psfpSgBaseSec').value || '0', 10);
      const ns = parseInt(document.getElementById('psfpSgBaseNs').value || '0', 10);
      const num = parseInt(document.getElementById('psfpSgCycleNum').value || '1', 10);
      const den = parseInt(document.getElementById('psfpSgCycleDen').value || '1', 10);
      const states = (document.getElementById('psfpSgStates').value || '').trim();

      const base = psfpBase() + 'stream-gates/stream-gate-instance-table';
      const yang = {};
      yang[base + '/stream-gate-instance-id'] = id;
      if (!isNaN(sec)) yang[base + '/admin-base-time/seconds'] = sec;
      if (!isNaN(ns)) yang[base + '/admin-base-time/nanoseconds'] = ns;
      if (!isNaN(num)) yang[base + '/admin-cycle-time/numerator'] = num;
      if (!isNaN(den)) yang[base + '/admin-cycle-time/denominator'] = den;
      if (states) yang[base + '/admin-gate-states'] = states;

      const sidObj = yangToSid(yang);
      const payload = cbor.encode(sidObj);
      const resp = await sendCoapRequest('PUT', base, payload);
      alert(`Stream gate updated (code ${resp.code})`);
    } catch (e) {
      alert('Failed to apply Stream Gate: ' + e.message);
    }
  };

  // TSN Apply functions (build minimal YANG JSON -> SID -> CBOR -> CoAP PUT)
  window.applyTAS = async () => {
    try {
      const iface = (document.getElementById('tsnIface').value || '').trim();
      if (!iface) return alert('Interface name is required');
      const cycle = parseInt(document.getElementById('tasCycleNs').value || '0', 10);
      const base = parseInt(document.getElementById('tasBaseTimeNs').value || '0', 10);
      const gatesStr = (document.getElementById('tasGates').value || '').trim();
      const gates = gatesStr ? gatesStr.split(',').map(s => s.trim()) : [];

      // YANG path and minimal structure for TAS
      const path = `/ieee802-dot1q-sched:interfaces/interface[name='${iface}']/gate-parameters`;
      const yang = {};
      yang[path] = {
        'admin-base-time': base,
        'admin-cycle-time': cycle,
        // Represent control list minimally by masks if provided
        'admin-control-list': gates.map((mask, idx) => ({ 'index': idx, 'gate-states': mask }))
      };

      const sidObj = yangToSid(yang);
      const payload = cbor.encode(sidObj);
      const resp = await sendCoapRequest('PUT', path, payload);
      alert(`TAS updated (code ${resp.code})`);
    } catch (e) {
      alert('Failed to apply TAS: ' + e.message);
    }
  };

  window.applyCBS = async () => {
    try {
      const iface = (document.getElementById('tsnIface').value || '').trim();
      if (!iface) return alert('Interface name is required');
      const cls = parseInt(document.getElementById('cbsClass').value || '0', 10);
      const idle = parseInt(document.getElementById('cbsIdleSlope').value || '0', 10);
      const send = parseInt(document.getElementById('cbsSendSlope').value || '0', 10);

      const path = `/ieee802-dot1q-sched:interfaces/interface[name='${iface}']/scheduler`;
      const yang = {};
      yang[path] = {
        'traffic-class-table': [{ 'traffic-class': cls, 'idle-slope': idle, 'send-slope': send }]
      };

      const sidObj = yangToSid(yang);
      const payload = cbor.encode(sidObj);
      const resp = await sendCoapRequest('PUT', path, payload);
      alert(`CBS updated (code ${resp.code})`);
    } catch (e) {
      alert('Failed to apply CBS: ' + e.message);
    }
  };

  window.applyPTP = async () => {
    try {
      const inst = (document.getElementById('ptpInstance').value || '0').trim();
      const domain = parseInt(document.getElementById('ptpDomain').value || '0', 10);
      const twoStep = document.getElementById('ptpTwoStep').value === 'true';

      const path = `/ieee1588-ptp:ptp/instance[instance-index='${inst}']`;
      const yang = {};
      yang[path] = { 'domain-number': domain, 'two-step-flag': twoStep };

      const sidObj = yangToSid(yang);
      const payload = cbor.encode(sidObj);
      const resp = await sendCoapRequest('PUT', path, payload);
      alert(`PTP updated (code ${resp.code})`);
    } catch (e) {
      alert('Failed to apply PTP: ' + e.message);
    }
  };
  
  async function autoLoadCoreconf() {
    // Try stored config
    const storedCfg = localStorage.getItem('velocitydrivesp_coreconf_config');
    let sources = [];
    if (storedCfg) {
      try { sources = JSON.parse(storedCfg)?.coreconfSources || []; } catch {}
    }

    // Try config.json if no stored config
    if (!sources.length) {
      try {
        const res = await fetch('config.json', { cache: 'no-store' });
        if (res.ok) {
          const cfg = await res.json();
          sources = cfg?.coreconfSources || [];
        }
      } catch {}
    }

    for (const src of sources) {
      if (src.type === 'githubContents') {
        const ok = await loadFromGitHubContents(src.owner, src.repo, src.path || '');
        if (ok) return true;
      }
      // Future: add 'zipUrl' with JSZip/tar support here
    }
    return false;
  }

  async function loadFromGitHubContents(owner, repo, path) {
    try {
      const api = `https://api.github.com/repos/${owner}/${repo}/contents/${encodeURIComponent(path)}`;
      const res = await fetch(api, { headers: { 'Accept': 'application/vnd.github+json' } });
      if (!res.ok) return false;
      const list = await res.json();
      const sidFiles = (Array.isArray(list) ? list : []).filter(item => item.type === 'file' && /\.sid$/i.test(item.name));
      if (sidFiles.length === 0) return false;

      // Fetch with limited concurrency
      const concurrency = 8;
      const mapping = {};
      const moduleStats = {};
      let idx = 0;
      async function worker() {
        while (idx < sidFiles.length) {
          const i = idx++;
          const item = sidFiles[i];
          try {
            const r = await fetch(item.download_url, { cache: 'no-store' });
            if (!r.ok) continue;
            const json = await r.json();
            const moduleName = json['module-name'] || 'unknown';
            let count = 0;
            for (const it of json.items || []) {
              if (it.namespace === 'data' && it.sid && it.identifier) {
                mapping[it.sid] = it.identifier;
                count++;
              }
            }
            moduleStats[moduleName] = count;
          } catch (_) {}
        }
      }
      await Promise.all(Array.from({ length: Math.min(concurrency, sidFiles.length) }, () => worker()));

      if (Object.keys(mapping).length > 0) {
        window.yangSidMap = mapping;
        window.moduleStats = moduleStats;
        window.SIDStorage?.save && window.SIDStorage.save(mapping);
        try { localStorage.setItem('velocitydrivesp_sid_last_updated', String(Date.now())); } catch {}
        if (window.YangTreeBuilder) {
          const treeBuilder = new YangTreeBuilder(window.yangSidMap);
          treeBuilder.renderTree('yangTree');
        }
        updateStatistics?.();
        return true;
      }
      return false;
    } catch { return false; }
  }
});
</script>
</body>
</html>
